{"version":3,"sources":["shared/common/SignalRNotifications.ts","shared/common/DurableEntityClientStateContainer.ts","common/DurableHttpClient.ts","shared/common/Constants.ts","common/EntityStateMap.ts","common/DurableEntitySet.ts","shared/HealthCheckState.ts","App.tsx","index.tsx"],"names":["EntityStateChangedMessage","entityName","entityKey","version","stateDiff","isEntityDestructed","msg","FormatEntityId","DurableEntityClientStateContainer","state","entityId","match","exec","entityNameLowerCase","BackendBaseUri","DurableHttpClient","_configFabric","NullLogger","instance","request","url","includes","config","this","accessTokenFactory","then","accessToken","headers","fakeUserNamePromise","fakeUserName","DefaultHttpClient","EntityStateMap","_maxKnownEntityIdsToPersist","States","LocalStorageKnownIdsKey","Object","assign","stateContainer","localStorage","entityIds","keys","slice","setItem","JSON","stringify","entityIdsJson","getItem","parse","filter","id","GetEntityNameAndKey","removeItem","DurableEntitySet","attachToAll","items","_entityNameLowerCase","toLowerCase","makeObservable","observable","attachAllEntities","initSignalR","EntitySets","fetchAndApplyKnownEntityStates","fetchAndApplyAllEntityStates","EntityStates","getState","attachEntity","undefined","createEntity","signalName","argument","signalEntity","callEntity","metadata","updateEntityMetadata","initialState","existingEntity","makeAutoObservable","fetchAndApplyEntityState","uri","encodeURI","HttpClient","post","content","Promise","resolve","reject","response","correlationId","SignalResultPromises","Config","logger","entityState","entitySet","push","i","length","splice","desiredVersion","retryCount","currentEntityState","get","Error","applyStateChangesFrom","entityAdded","addOrUpdateState","catch","err","MaxRetryCount","setTimeout","RetryBaseIntervalMs","log","LogLevel","existingEntityStates","getStatesCopy","item","existingStateContainer","Information","deletedEntityId","removeState","nameAndKey","entityDeleted","getStoredEntityIds","stateContainers","Warning","removeStoredEntityIds","GetEntityId","Trace","expectedVersion","rfc6902","responsePromise","errorMessage","result","SignalRConn","HubConnectionBuilder","withUrl","httpClient","build","on","entityStateChangedMessageHandler","entitySignalResponseHandler","onclose","reconnectToSignalR","start","SignalRReconnectIntervalInMs","incomingEntityState","diff","DefaultMaxKnownEntityIdsToPersist","maxKnownEntityIdsToPersist","SymptomsEnum","setup","userName","fetch","r","json","user_id","prompt","l","console","appState","msgText","history","symptoms","App","observer","AppBar","position","color","className","Toolbar","map","symptom","Chip","label","variant","List","ListItem","Paper","style","marginLeft","isFromServer","Typography","text","TextField","fullWidth","InputLabelProps","shrink","size","value","onChange","evt","target","onKeyPress","key","preventDefault","sendMessage","Box","width","Button","onClick","AccountCircle","React","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.ec4cf822.chunk.js","sourcesContent":["import * as rfc6902 from 'rfc6902';\n\nexport class EntityStateChangedMessage {\n    \n    entityName: string = '';\n    entityKey: string = '';\n    version: number = 0;\n    stateDiff: rfc6902.Operation[] = [];\n    isEntityDestructed: boolean = false;\n\n    static GetEntityId(msg: EntityStateChangedMessage): string {\n        return EntityStateChangedMessage.FormatEntityId(msg.entityName, msg.entityKey);\n    }\n\n    static FormatEntityId(entityName: string, entityKey: string): string {\n        return `@${entityName}@${entityKey}`;\n    }\n}\n\nexport class EntitySignalResponseMessage {\n\n    entityName: string = '';\n    entityKey: string = '';\n    correlationId: string = '';\n    result: any;\n    errorMessage: string = '';\n}","\n// A client-side wrapper around entity's state, with some extra metadata added\nexport class DurableEntityClientStateContainer {\n\n    version: number = 0;\n    state: object = {};\n\n    // Helper method for parsing entityIds\n    public static GetEntityNameAndKey(entityId: string): { entityNameLowerCase: string, entityKey: string } {\n        \n        const match = /@([^@]+)@(.+)/.exec(entityId);\n        return { entityNameLowerCase: !match ? '' : match[1], entityKey: !match ? '' : match[2] };\n    }\n}","import { DefaultHttpClient, HttpRequest, HttpResponse, NullLogger } from '@aspnet/signalr';\n\nimport { IDurableEntitySetConfig } from './IDurableEntitySetConfig';\nimport { ClientPrincipalHeaderName } from '../shared/common/Constants';\n\nexport const BackendBaseUri = '/a/p/i';\n\n// Custom HttpClient implementation for the purposes of DurableEntitySet\nexport class DurableHttpClient extends DefaultHttpClient {\n\n    constructor(private _configFabric: () => IDurableEntitySetConfig) {\n        super(NullLogger.instance);\n    }\n\n    send(request: HttpRequest): Promise<HttpResponse> {\n\n        // Applying custom config settings, but only when calling our backend\n\n        if (request.url!.includes(BackendBaseUri)) {\n\n            const config = this._configFabric();\n\n            if (!!config.accessTokenFactory) {\n                return config.accessTokenFactory().then(accessToken => {\n\n                    request.headers = {}\n                    request.headers['Authorization'] = 'Bearer ' + accessToken;\n\n                    return super.send(request);\n                });\n            }\n\n            if (!!config.fakeUserNamePromise) {\n                return config.fakeUserNamePromise.then(fakeUserName => {\n\n                    if (!!fakeUserName) {\n                        request.headers = {}\n                        request.headers[ClientPrincipalHeaderName] = fakeUserName;\n                    }\n\n                    return super.send(request);\n                });\n            }\n        }\n\n        return super.send(request);\n    }\n}\n","\nexport const SignalRClientHandlerName = \"entity-state-changed\";\n\nexport const SignalRSignalResponseHandlerName = \"entity-signal-response\";\n\nexport const ClientPrincipalHeaderName = 'x-ms-client-principal-name';\n\nexport const UpdateMetadataServiceMethodName = \"$update-entity-internal-metadata\";\n","import { DurableEntityClientStateContainer } from '../shared/common/DurableEntityClientStateContainer';\n\n// Map-like storage for all known entity states\nexport class EntityStateMap {\n\n    constructor(private _maxKnownEntityIdsToPersist: () => number) {\n    }\n\n    public getState(entityId: string): DurableEntityClientStateContainer {\n        return this.States[entityId];\n    }\n\n    public getStatesCopy(): { [entityId: string]: DurableEntityClientStateContainer } {\n        return Object.assign({}, this.States);\n    }\n\n    public addOrUpdateState(entityId: string, stateContainer: DurableEntityClientStateContainer): void {\n        this.States[entityId] = stateContainer;\n\n        if (!!localStorage) {\n\n            const entityIds = Object.keys(this.States).slice(0, this._maxKnownEntityIdsToPersist());\n            localStorage.setItem(this.LocalStorageKnownIdsKey, JSON.stringify(entityIds));\n        }\n    }\n\n    public removeState(entityId: string): void {\n        delete this.States[entityId];\n\n        if (!!localStorage) {\n\n            const entityIds = Object.keys(this.States).slice(0, this._maxKnownEntityIdsToPersist());\n            localStorage.setItem(this.LocalStorageKnownIdsKey, JSON.stringify(entityIds));\n        }\n    }\n\n    public getStoredEntityIds(entityNameLowerCase: string): string[] {\n\n        if (!localStorage) {\n            return [];\n        }\n\n        const entityIdsJson = localStorage.getItem(this.LocalStorageKnownIdsKey);\n        if (!entityIdsJson) {\n            return [];\n        }\n\n        return (JSON.parse(entityIdsJson) as string[])\n            .filter(id => DurableEntityClientStateContainer.GetEntityNameAndKey(id).entityNameLowerCase === entityNameLowerCase);\n    }\n\n    public removeStoredEntityIds(entityNameLowerCase: string): void {\n        if (!!localStorage) {\n            localStorage.removeItem(this.LocalStorageKnownIdsKey);\n        }\n    }\n\n    private States: { [entityId: string]: DurableEntityClientStateContainer } = {};\n    private readonly LocalStorageKnownIdsKey = 'DurableEntitySetKnownEntityIds';\n}","import { makeAutoObservable, makeObservable, observable } from 'mobx';\nimport { HubConnectionBuilder, HubConnection, NullLogger, LogLevel } from '@aspnet/signalr';\nimport * as rfc6902 from 'rfc6902';\n\nimport { ISetEntityMetadataRequest } from '../shared/common/ISetEntityMetadataRequest';\nimport { EntityStateChangedMessage, EntitySignalResponseMessage } from '../shared/common/SignalRNotifications';\nimport { SignalRClientHandlerName, SignalRSignalResponseHandlerName, UpdateMetadataServiceMethodName } from '../shared/common/Constants';\nimport { DurableEntityClientStateContainer } from '../shared/common/DurableEntityClientStateContainer';\nimport { IDurableEntitySetConfig } from './IDurableEntitySetConfig';\nimport { DurableHttpClient, BackendBaseUri } from './DurableHttpClient';\nimport { EntityStateMap } from './EntityStateMap';\n\nexport type EntityStateWithKey = { entityKey: string };\n\n// Client-side container for Durable Entities\nexport class DurableEntitySet<TState extends object> {\n\n    // All attached entities will appear in this observable array\n    items: (TState & EntityStateWithKey)[] = [];\n    \n    constructor(entityName: string, attachToAll: boolean = true) {\n\n        // Inside Durable Functions entity names are always lower-case, so we need to convert\n        this._entityNameLowerCase = entityName.toLowerCase();\n\n        makeObservable(this, { items: observable });\n        \n        if (attachToAll) {\n            this.attachAllEntities();\n        }\n    }\n\n    // Attach all entities of this type (that type you previously passed to ctor).\n    // Preloads all existing entities of this type and then automatically captures all newly created entities.\n    attachAllEntities(): Promise<void> {\n\n        DurableEntitySet.initSignalR();\n\n        // Registering ourselves as listeners for this type of entity\n        DurableEntitySet.EntitySets[this._entityNameLowerCase] = this.items;\n\n        // First trying to fetch states for stored entityIds\n        return DurableEntitySet.fetchAndApplyKnownEntityStates(this._entityNameLowerCase)\n            // Then still always doing a mass-load, because some entities might be added/removed during the offline period\n            .then(() => DurableEntitySet.fetchAndApplyAllEntityStates(this._entityNameLowerCase));\n    }\n\n    // Manually attach a single entity with specific key\n    attachEntity(entityKey: string): void {\n\n        const entityId = EntityStateChangedMessage.FormatEntityId(this._entityNameLowerCase, entityKey);\n\n        if (!!DurableEntitySet.EntityStates.getState(entityId)) {\n            return;\n        }\n\n        // Registering ourselves as listeners for this particular entity\n        DurableEntitySet.EntitySets[entityId] = this.items;\n        \n        DurableEntitySet.attachEntity(this._entityNameLowerCase, entityKey, undefined as any);\n    }\n\n    // Creates (or fetches existing) an entity\n    createEntity(entityKey: string): void {\n\n        DurableEntitySet.createEntity(this._entityNameLowerCase, entityKey, undefined as any);\n    }\n\n    // Sends a signal to the given entity\n    signalEntity(entityKey: string, signalName: string, argument?: any): Promise<void> {\n\n        return DurableEntitySet.signalEntity(this._entityNameLowerCase, entityKey, signalName, argument);\n    }\n\n    // Sends a signal to the given entity and returns a promise with results\n    callEntity(entityKey: string, signalName: string, argument?: any): Promise<any> {\n\n        return DurableEntitySet.callEntity(this._entityNameLowerCase, entityKey, signalName, argument);\n    }\n\n    // Updates metadata of the given entity\n    updateEntityMetadata(entityKey: string, metadata: ISetEntityMetadataRequest): Promise<void> {\n\n        return DurableEntitySet.updateEntityMetadata(this._entityNameLowerCase, entityKey, metadata);\n    }\n\n    // Lower-cased entity class name\n    private readonly _entityNameLowerCase: string;\n\n    // Produces a single observable state instance for an existing entity\n    static attachEntity<TState extends object>(entityName: string, entityKey: string, initialState: TState): TState {\n\n        DurableEntitySet.initSignalR();\n\n        // Inside Durable Functions entity names are always lower-case, so we need to convert\n        const entityNameLowerCase = entityName.toLowerCase();\n\n        const existingEntity = this.EntityStates.getState(EntityStateChangedMessage.FormatEntityId(entityNameLowerCase, entityKey));\n        if (!!existingEntity) {\n            // If it is a known entity, then just returning it\n            return existingEntity.state as TState;\n        }\n\n        if (!!initialState) {\n            makeAutoObservable(initialState);\n        }\n\n        // Try to asynchronously retrieve the state from server\n        this.fetchAndApplyEntityState(entityNameLowerCase, entityKey, 0, 0, initialState);\n\n        return initialState;\n    }\n\n    // Creates (or fetches existing) and produces a single observable state instance for a newly created entity\n    static createEntity<TState extends object>(entityName: string, entityKey: string, initialState: TState): TState {\n\n        // This empty request will create the entity, if it doesn't exist yet.\n        this.updateEntityMetadata(entityName, entityKey, {});\n\n        return this.attachEntity(entityName, entityKey, initialState);\n    }\n\n    // Sends a signal to the given entity\n    static signalEntity(entityName: string, entityKey: string, signalName: string, argument?: any): Promise<void> {\n\n        // Inside Durable Functions entity names are always lower-case, so we need to convert\n        const entityNameLowerCase = entityName.toLowerCase();\n\n        const uri = `${BackendBaseUri}/entities/${encodeURI(entityNameLowerCase)}/${encodeURI(entityKey)}/${encodeURI(signalName)}`;\n        return this.HttpClient.post(uri, { content: JSON.stringify(argument) }).then();\n    }\n\n    // Sends a signal to the given entity and returns a promise with results\n    static callEntity(entityName: string, entityKey: string, signalName: string, argument?: any): Promise<any> {\n\n        // Inside Durable Functions entity names are always lower-case, so we need to convert\n        const entityNameLowerCase = entityName.toLowerCase();\n\n        const uri = `${BackendBaseUri}/entities/${encodeURI(entityNameLowerCase)}/${encodeURI(entityKey)}/${encodeURI(signalName)}`;\n\n        return new Promise<any>((resolve, reject) => {\n\n            this.HttpClient.post(uri, { content: JSON.stringify(argument) }).then(response => {\n\n                const correlationId: string = JSON.parse(response.content as string).correlationId;\n                this.SignalResultPromises[correlationId] = { resolve, reject };\n\n            }, reject);\n        });\n    }\n\n    // Updates metadata of the given entity\n    static updateEntityMetadata(entityName: string, entityKey: string, metadata: ISetEntityMetadataRequest): Promise<void> {\n\n        return this.signalEntity(entityName, entityKey, UpdateMetadataServiceMethodName, metadata);\n    }\n\n    // Optionally setup with these optional settings\n    static setup(config: IDurableEntitySetConfig): void {\n        this.Config = config;\n        if (!this.Config.logger) {\n            this.Config.logger = NullLogger.instance;\n        }\n    }\n\n    private static Config: IDurableEntitySetConfig = { logger: NullLogger.instance };\n    private static HttpClient: DurableHttpClient = new DurableHttpClient(() => DurableEntitySet.Config);\n    private static EntitySets: { [entityName: string]: EntityStateWithKey[] } = {};\n    private static SignalResultPromises: { [correlationId: string]: { resolve: (res: any) => void, reject: (err: Error) => void } } = {};\n\n    private static SignalRConn: HubConnection;\n\n    private static readonly SignalRReconnectIntervalInMs = 5000;\n    private static readonly MaxRetryCount = 6;\n    private static readonly RetryBaseIntervalMs = 500;\n    private static readonly DefaultMaxKnownEntityIdsToPersist = 100;\n\n    private static EntityStates = new EntityStateMap(() =>\n        DurableEntitySet.Config.maxKnownEntityIdsToPersist === undefined ?\n            DurableEntitySet.DefaultMaxKnownEntityIdsToPersist :\n            DurableEntitySet.Config.maxKnownEntityIdsToPersist\n    );\n\n    private static entityAdded(entityNameLowerCase: string, entityKey: string, entityState: EntityStateWithKey) {\n\n        const entityId = EntityStateChangedMessage.FormatEntityId(entityNameLowerCase, entityKey);\n\n        // Searching for entitySet either for this particular entity or for this type of entity\n        var entitySet = this.EntitySets[entityId];\n        if (!entitySet) {\n            entitySet = this.EntitySets[entityNameLowerCase];\n        } else {\n            delete this.EntitySets[entityId];\n        }\n\n        if (!entitySet) {\n            return;\n        }\n\n        // Adding the entityKey property to the state object, to allow binding commands\n        entityState.entityKey = entityKey;\n        entitySet.push(entityState);\n    }\n\n    private static entityDeleted(entityNameLowerCase: string, entityKey: string) {\n\n        const entitySet = this.EntitySets[entityNameLowerCase];\n        if (!entitySet) {\n            return;\n        }\n\n        for (var i = 0; i < entitySet.length; i++) {\n\n            if (entitySet[i].entityKey === entityKey) {\n                entitySet.splice(i, 1);\n                break;\n            }\n        }\n    }\n\n    private static fetchAndApplyEntityState(entityNameLowerCase: string, entityKey: string, desiredVersion: number, retryCount: number, currentEntityState: any = null): void {\n\n        const uri = `${BackendBaseUri}/entities/${encodeURI(entityNameLowerCase)}/${encodeURI(entityKey)}`;\n        this.HttpClient.get(uri).then(response => {\n\n            const stateContainer = JSON.parse(response.content as string) as DurableEntityClientStateContainer;\n            const entityId = EntityStateChangedMessage.FormatEntityId(entityNameLowerCase, entityKey);\n\n            if (!!desiredVersion && (stateContainer.version < desiredVersion)) {\n                throw new Error(`Expected ${entityId} of version ${desiredVersion}, but got version ${stateContainer.version}`);\n            }\n\n            if (!currentEntityState) {\n\n                // If there is no existing state, then using the newly arrived state object\n                currentEntityState = stateContainer.state;\n                makeAutoObservable(currentEntityState);\n                \n            } else {\n\n                // Otherwise applying the change to the existing object, so that UI is re-rendered\n                this.applyStateChangesFrom(currentEntityState, stateContainer.state);\n            }\n\n            if (!this.EntityStates.getState(entityId)) {\n                \n                // Adding the newly-arrived state into collections, if any\n                this.entityAdded(entityNameLowerCase, entityKey, currentEntityState);\n            }\n\n            // (Re)registering this entity\n            this.EntityStates.addOrUpdateState(entityId, { state: currentEntityState, version: stateContainer.version });\n\n        }).catch(err => {\n\n            if (retryCount < this.MaxRetryCount) {\n\n                // Retrying\n                retryCount++;\n                setTimeout(() => {\n\n                    this.fetchAndApplyEntityState(entityNameLowerCase, entityKey, desiredVersion, retryCount, currentEntityState);\n\n                }, retryCount * this.RetryBaseIntervalMs);\n                \n            } else {\n\n                this.Config.logger!.log(LogLevel.Error, `DurableEntitySet: failed to fetch entity state: ${err}`);\n            }\n        });\n    }\n\n    private static fetchAndApplyAllEntityStates(entityNameLowerCase: string): Promise<void> {\n\n        // Making a shallow copy of current known states BEFORE triggering a call, \n        // so that if any entity is removed during the call, it doesn't re-appear.\n        const existingEntityStates = this.EntityStates.getStatesCopy();\n\n        const uri = `${BackendBaseUri}/entities/${encodeURI(entityNameLowerCase)}`;\n        return this.HttpClient.get(uri).then(response => {\n\n            for (var item of JSON.parse(response.content as string)) {\n\n                const entityKey = item.entityKey;\n                const entityId = EntityStateChangedMessage.FormatEntityId(entityNameLowerCase, entityKey);\n                const stateContainer = item as DurableEntityClientStateContainer;\n\n                const existingStateContainer = existingEntityStates[entityId];\n                delete existingEntityStates[entityId];\n\n                if (!existingStateContainer) {\n\n                    makeAutoObservable(stateContainer.state);\n                    this.EntityStates.addOrUpdateState(entityId, stateContainer);\n\n                    // Adding the newly-arrived state into collections, if any\n                    this.entityAdded(entityNameLowerCase, entityKey, stateContainer.state as any);\n                    \n\n                } else if (existingStateContainer.version < stateContainer.version) {\n\n                    this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: ${entityId}, local version ${existingStateContainer.version}, remote version ${stateContainer.version}. State was updated.`);\n\n                    // Otherwise applying the change to the existing object, so that UI is re-rendered\n                    this.applyStateChangesFrom(existingStateContainer.state, stateContainer.state);\n                    existingStateContainer.version = stateContainer.version;\n\n                } else {\n\n                    this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: ${entityId} is already known and is up to date. Skipping.`);\n                }\n            }\n\n            // Dropping instances that might have appeared up to this point\n            for (const deletedEntityId in existingEntityStates) {\n\n                this.EntityStates.removeState(deletedEntityId);\n                const nameAndKey = DurableEntityClientStateContainer.GetEntityNameAndKey(deletedEntityId);\n                this.entityDeleted(nameAndKey.entityNameLowerCase, nameAndKey.entityKey);\n            }\n\n        }).catch(err => {\n            this.Config.logger!.log(LogLevel.Error, `DurableEntitySet: failed to fetch entity states: ${err}`);\n        });\n    }\n\n    private static fetchAndApplyKnownEntityStates(entityNameLowerCase: string): Promise<void> {\n\n        const entityIds = this.EntityStates.getStoredEntityIds(entityNameLowerCase);\n\n        // Making a shallow copy of current known states BEFORE triggering a call, \n        // so that if any entity is removed during the call, it doesn't re-appear.\n        const existingEntityStates = this.EntityStates.getStatesCopy();\n\n        const uri = `${BackendBaseUri}/entities`;\n        return this.HttpClient.post(uri, { content: JSON.stringify(entityIds) }).then(response => {\n\n            const stateContainers = JSON.parse(response.content as string) as DurableEntityClientStateContainer[];\n\n            for (var i = 0; i < entityIds.length; i++) {\n\n                const entityId = entityIds[i];\n                const nameAndKey = DurableEntityClientStateContainer.GetEntityNameAndKey(entityId);\n                const stateContainer = stateContainers[i];\n\n                const existingStateContainer = existingEntityStates[entityId];\n                if (!existingStateContainer) {\n\n                    makeAutoObservable(stateContainer.state);\n                    this.EntityStates.addOrUpdateState(entityId, stateContainer);\n\n                    // Adding the newly-arrived state into collections, if any\n                    this.entityAdded(nameAndKey.entityNameLowerCase, nameAndKey.entityKey, stateContainer.state as any);\n                    \n\n                } else if (existingStateContainer.version < stateContainer.version) {\n\n                    this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: ${entityId}, local version ${existingStateContainer.version}, remote version ${stateContainer.version}. State was updated.`);\n\n                    // Otherwise applying the change to the existing object, so that UI is re-rendered\n                    this.applyStateChangesFrom(existingStateContainer.state, stateContainer.state);\n                    existingStateContainer.version = stateContainer.version;\n\n                } else {\n\n                    this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: ${entityId} is already known and is up to date. Skipping.`);\n                }\n            }\n\n        }).catch(err => {\n\n            this.Config.logger!.log(LogLevel.Warning, `DurableEntitySet: failed to fetch known entity states: ${err}`);\n\n            // In most cases this error indicates, that our stored entityIds are no longer valid, so we'd better drop them\n            this.EntityStates.removeStoredEntityIds(entityNameLowerCase);\n        });\n    }\n    \n    private static entityStateChangedMessageHandler(msg: EntityStateChangedMessage): void {\n\n        const entityId = EntityStateChangedMessage.GetEntityId(msg);\n\n        this.Config.logger!.log(LogLevel.Trace, `DurableEntitySet: ${entityId} changed to version ${msg.version}`);\n\n        const existingStateContainer = this.EntityStates.getState(entityId);\n        if (msg.isEntityDestructed) {\n\n            this.EntityStates.removeState(entityId);\n\n            this.entityDeleted(msg.entityName, msg.entityKey);\n\n        } else if (!existingStateContainer) {\n\n            // If anybody is attached to this entity or this type of entity\n            if (!!this.EntitySets[entityId] || !!this.EntitySets[msg.entityName]) {\n                \n                // This entity is not known to us yet, so just trying to fetch its state from server\n                setTimeout(() => this.fetchAndApplyEntityState(msg.entityName, msg.entityKey, msg.version, 0), this.RetryBaseIntervalMs);\n            }\n           \n        } else {\n\n            const expectedVersion = existingStateContainer.version + 1;\n            if (msg.version > expectedVersion) {\n                \n                // Missed some updates, so now need to reload the state from server\n                this.fetchAndApplyEntityState(msg.entityName, msg.entityKey, msg.version, 0, existingStateContainer.state);\n\n            } else if (msg.version === expectedVersion) {\n\n                // Applying the change\n                rfc6902.applyPatch(existingStateContainer.state, msg.stateDiff);\n                existingStateContainer.version = msg.version;\n            }            \n        }\n    }\n\n    private static entitySignalResponseHandler(msg: EntitySignalResponseMessage): void {\n\n        const responsePromise = this.SignalResultPromises[msg.correlationId];\n        if (!responsePromise) {\n            return;\n        }\n\n        if (!msg.errorMessage) {\n            responsePromise.resolve(msg.result);\n        } else {\n            responsePromise.reject(new Error(msg.errorMessage));\n        }\n\n        delete this.SignalResultPromises[msg.correlationId];\n    }\n\n    private static initSignalR(): void {\n\n        if (!!this.SignalRConn) {\n            return;\n        }\n\n        // Configuring SignalR\n        this.SignalRConn = new HubConnectionBuilder()\n            .withUrl(`${BackendBaseUri}`, { httpClient: this.HttpClient, logger: this.Config.logger })\n            .build();\n\n        // Mounting event handlers\n        this.SignalRConn.on(SignalRClientHandlerName, msg => this.entityStateChangedMessageHandler(msg));\n        this.SignalRConn.on(SignalRSignalResponseHandlerName, msg => this.entitySignalResponseHandler(msg));\n\n        // Background reconnects are essential here. That's because in 'Default' or 'Classic' service mode\n        // clients get forcibly disconnected, when your backend restarts.\n        this.SignalRConn.onclose(() => this.reconnectToSignalR());\n\n        // Establishing SignalR connection\n        this.SignalRConn.start().then(\n            () => {\n                this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: successfully connected to SignalR`);\n            }, err => {\n                this.Config.logger!.log(LogLevel.Error, `DurableEntitySet: failed to connect to SignalR: ${err}`);\n            });\n    }\n\n    private static reconnectToSignalR() {\n\n        this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: reconnecting to SignalR...`);\n        this.SignalRConn.start().then(() => {\n            this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: reconnected to SignalR`);\n        }, () => {\n            setTimeout(() => this.reconnectToSignalR(), this.SignalRReconnectIntervalInMs);\n        });\n    }\n\n    // Applies incoming changes to an existing observable object so, that UI is re-rendered\n    private static applyStateChangesFrom(currentEntityState: any, incomingEntityState: any): void {\n\n        // Need to preserve the entityKey field, if it is set\n        incomingEntityState.entityKey = currentEntityState.entityKey;\n\n        const diff = rfc6902.createPatch(currentEntityState, incomingEntityState);\n        rfc6902.applyPatch(currentEntityState, diff);\n    }\n}\n","\nexport class ChatMessage {\n\n    text: string = '';\n    timestamp: Date = new Date();\n    isFromServer: boolean = false;\n}\n\nexport enum SymptomsEnum {\n    Fever = 1,\n    Headache,\n    Nausea,\n    Rash,\n    Diarrhea,\n    // to be extended...\n}\n\n// Health check state\nexport class HealthCheckState\n{\n    history: ChatMessage[] = [];\n    symptoms: SymptomsEnum[] = [];\n}","import React from 'react';\nimport { makeAutoObservable } from 'mobx';\nimport { observer } from 'mobx-react';\nimport { AppBar, Button, Box, Chip, Grid, LinearProgress, List, ListItem, Paper, TextField, Toolbar, Typography } from '@material-ui/core';\nimport { AccountCircle } from '@material-ui/icons';\n\nimport { DurableEntitySet } from './common/DurableEntitySet';\nimport { HealthCheckState, SymptomsEnum } from './shared/HealthCheckState';\n\n// Optional setup\nDurableEntitySet.setup({\n\n    fakeUserNamePromise: new Promise<string | null>((resolve) => {\n\n        var userName = '';\n\n        // Trying to fetch current user name from server - this should work when deployed to Azure and EasyAuth properly configured\n        fetch('/.auth/me').then(r => r.json()).then(result => {\n\n            if (!result || !result.length) {\n                throw new Error('EasyAuth seems to be not configured. Falling back to a fake user name');\n            }\n\n            userName = result[0].user_id;\n\n            // By returning null here we tell DurableEntitySet to proceed with using EasyAuth\n            resolve(null);\n\n        }).catch(() => {\n\n            // Asking the user for some fake user name. Obviously, we should never do it like that in production.\n            userName = prompt('Enter your name:', 'Anonymous') as string;\n            resolve(userName);\n        });\n    }),\n\n    logger: { log: (l, msg: string) => console.log(msg) }\n});\n\nconst entityName = 'HealthCheckEntity';\nconst entityKey = 'my-health-check';\n\nconst appState = makeAutoObservable({\n\n    msgText: '',\n\n    state: DurableEntitySet.createEntity(entityName, entityKey, new HealthCheckState())\n});\n\n// Rendering that entity state\nexport const App = observer(\n    class App extends React.Component {\n\n        private sendMessage() {\n\n            DurableEntitySet.signalEntity(entityName, entityKey, 'sendHealthCheck', appState.msgText);\n        }\n\n        render(): JSX.Element { return (<>\n\n            <AppBar position=\"static\" color=\"default\" className=\"app-bar\">\n                <Toolbar>\n\n                    Your symptoms so far:\n\n                    {appState.state.symptoms.map(symptom => (\n                        <Chip label={SymptomsEnum[symptom]} color=\"secondary\" variant=\"outlined\" className=\"appointment-status-chip\" />\n                    ))}\n\n                </Toolbar>\n            </AppBar>\n\n            <List>\n\n                {appState.state.history.map(msg => (<ListItem><Paper className=\"appointment-paper\">\n                \n                    <Paper style={{ marginLeft: !msg.isFromServer ? 20 : 0 }}>\n\n                        <Typography>{msg.text}</Typography>\n\n                    </Paper>\n                \n                </Paper></ListItem>))}\n\n            </List>\n\n            <AppBar position=\"static\" color=\"default\" className=\"app-bar\">\n                <Toolbar>\n\n                    <TextField\n                        fullWidth\n                        label=\"Your message\"\n                        InputLabelProps={{ shrink: true }}\n                        variant=\"outlined\"\n                        size=\"small\"\n                        value={appState.msgText}\n                        onChange={(evt) => appState.msgText = evt.target.value as string}\n                        onKeyPress={(evt) => {\n                            if (evt.key === 'Enter') {\n                                evt.preventDefault();\n                                this.sendMessage();\n                            }\n                        }}\n                    />\n\n                    <Box width={20} />\n\n                    <Button variant=\"contained\" color=\"default\" size=\"large\" className=\"new-appointment-button\"\n                        onClick={() => this.sendMessage()}\n                    >\n                        Send\n                    </Button>\n\n                    <Box width={40} />\n\n                    <AccountCircle />\n                    <Box width={5} />\n\n                </Toolbar>\n            </AppBar>\n\n\n        </>);}\n    }\n);","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport { App } from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}